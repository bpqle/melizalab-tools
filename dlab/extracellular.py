# -*- coding: utf-8 -*-
# -*- mode: python -*-
""" Utilities for extracellular experiments """
import re
import json
import logging
import quickspikes as qs

from dlab import pprox

log = logging.getLogger("dlab.extracellular")

#### present-audio

def audiolog_to_trials(trials, data_file, sync_dset="channel37", sync_thresh=1.0):
    """Parses a logfile from Margot's present_audio scripts for experiment structure

    trials: the "presentation" field in the json output of present_audio.py
    data_file: open handle to the hdf5 file generated by open-ephys during the recording
    sync_dset: the name of the dataset containing the synchronization signal
    sync_thresh: the threshold for detecting the sync signal
    trials: number of trials per stimulus
    """
    from arf import timestamp_to_float

    # Each element in this structure corresponds to a trial. In some cases the
    # data are stored as a dict/map, but the keys are just strings of the trial
    # number. The indices correspond to the entries in the arf file.
    n_trials = len(trials)
    expt_start = None
    sample_count = 0
    det = qs.detector(sync_thresh, 10)
    for i in range(n_trials):
        pproc = {"events": [], "index": i}
        pproc.update(trials[str(i)])
        entry_name = "/rec_%d" % i
        entry = data_file[entry_name]

        # get time relative to first trial
        entry_time = timestamp_to_float(entry.attrs["timestamp"])
        if expt_start is None:
            expt_start = entry_time
        pproc["offset"] = entry_time - expt_start
        # find the sync signal - we expect one and only one click
        dset = entry[sync_dset]
        pproc["recording"] = {
            "entry": pprox.wrap_uuid(entry.attrs["uuid"]),
            "start": int(sample_count),
            "stop": int(sample_count + dset.size),
            "sampling_rate": dset.attrs["sampling_rate"]
        }
        sample_count += dset.size
        sync = dset[:].astype("d")
        det.scale_thresh(sync.mean(), sync.std())
        clicks = det(sync)
        if len(clicks) != 1:
            log.error("%s: expected 1 click, detected %d", dset.name, len(clicks))
        else:
            pproc["stim_on"] = clicks[0] / dset.attrs["sampling_rate"]
        yield pproc


def audiolog_to_pprox_script(argv=None):
    """ CLI to generate a pprox from present_audio log """
    import sys
    import argparse
    import json
    import h5py as h5
    import nbank
    from dlab.core import setup_log

    p = argparse.ArgumentParser(
        description="generate pprox from trial structure in present_audio logfile"
    )
    p.add_argument("--debug", help="show verbose log messages", action="store_true")
    p.add_argument(
        "--output",
        "-o",
        type=argparse.FileType("w", encoding="utf-8"),
        default=sys.stdout,
        help="name of output file. If absent, outputs to stdout",
    )
    p.add_argument(
        "--sync",
        default="channel37",
        help="name of channel with synchronization signal",
    )
    p.add_argument(
        "--sync-thresh",
        default="30.0",
        type=float,
        help="threshold (z-score) for detecting synchronization clicks",
    )
    p.add_argument("logfile", help="log file generated by present_audio.py")
    p.add_argument("recording", help="neurobank id or URL for the ARF recording")
    args = p.parse_args(argv)
    setup_log(log, args.debug)

    datafile = nbank.get(args.recording, local_only=True)
    if datafile is None:
        p.error("unable to locate resource %s - is it deposited in neurobank?" % args.recording)
    log.info("%s -> '%s'", args.recording, datafile)

    with h5.File(datafile, "r") as afp:
        with open(args.logfile, "rt") as lfp:
            expt_log = json.load(lfp)
            trials = pprox.from_trials(
                audiolog_to_trials(
                    expt_log.pop("presentation"), afp, args.sync, args.sync_thresh
                )
            )
            trials.update(expt_log)
    json.dump(trials, args.output)

############### oeaudio-present:

def find_stim_dset(entry):
    """ Returns the first dataset that matches 'Network_Events.*_TEXT' """
    rex = re.compile(r"Network_Events-.*?TEXT")
    for name in entry:
        if rex.match(name) is not None:
            log.debug("  - using %s for stim log dataset", name)
            return entry[name]


def oeaudio_to_trials(data_file, sync_dset, sync_thresh=1.0):
    """Extracts trial information from an oeaudio-present experiment ARF file

    When using oeaudio-present, a single recording is made in response to all
    the stimuli. The stimulus presentation script sends network events to
    open-ephys to mark the start and stop of each stimulus. There is typically a
    significant lag between the 'start' event and the onset of the stimulus, due
    to buffering of the audio playback. However, the oeaudio-present script will
    play a synchronization click on a second channel by default. As long as the
    user remembers to record this channel, it can be used to correct the onset
    and offset values.

    """
    from arf import timestamp_to_float

    re_metadata = re.compile(r"metadata: (\{.*\})")
    re_start = re.compile(r"start (.*)")
    re_stop = re.compile(r"stop (.*)")
    expt_start = None
    index = 0
    for name, entry in data_file.items():
        log.info("- parsing trials in %s", entry)
        entry_time = timestamp_to_float(entry.attrs["timestamp"])
        log.info("  - start time %s", entry_time)
        if expt_start is None:
            expt_start = entry_time
        sync = entry[sync_dset]
        stims = find_stim_dset(entry)
        stim_sample_offset = int(sync.attrs["offset"] * sync.attrs["sampling_rate"])
        log.info("  - recording starts at sample %d", stim_sample_offset)
        pproc_base = {
            "events": [],
            "recording": {
                "trial": pprox.wrap_uuid(entry.attrs["uuid"])
                "sampling_rate": sync.attrs["sampling_rate"]
            }
        }
        this_trial = None
        for row in stims:
            time = row["start"]
            message = row["message"].decode("utf-8")
            m = re_metadata.match(message)
            try:
                metadata = json.loads(m.group(1))
            except (AttributeError, json.JSONDecodeError):
                pass
            else:
                pproc_base.update(metadata)
                continue
            m = re_start.match(message)
            if m is not None:
                this_trial = pproc_base.copy()
                stim = m.group(1)
                this_trial.update(
                    stim=stim, index=index
                )
                this_trial["recording"]["start"] = time - stim_sample_offset
                log.debug(
                    "  - trial %d (%s): start @ %d samples",
                    index, stim, time - stim_sample_offset
                )
                continue
            m = re_stop.match(message)
            if m is not None:
                stim = m.group(1)
                if this_trial is None or stim != this_trial["stim"]:
                    log.error(
                        "  - ERROR: stop event %s without matching start event",
                        m.group(1),
                    )
                    this_trial = None
                else:
                    this_trial["recording"]["stop"] = time - stim_sample_offset
                    log.debug(
                        "  - trial %d (%s): stop  @ %d samples",
                        index, stim, time - stim_sample_offset
                    )
                    index += 1
                    yield this_trial


def oeaudio_to_pprox_script(argv=None):
    import sys
    import argparse
    import h5py as h5
    from dlab.core import setup_log

    p = argparse.ArgumentParser(
        description="generate pprox from trial structure in oeaudio-present recording"
    )
    p.add_argument("--debug", help="show verbose log messages", action="store_true")
    p.add_argument(
        "--output",
        "-o",
        type=argparse.FileType("w", encoding="utf-8"),
        default=sys.stdout,
        help="name of output file. If absent, outputs to stdout",
    )
    p.add_argument(
        "--sync",
        default="sync",
        help="name of channel with synchronization signal",
    )
    p.add_argument("datafile", help="ARF file with recording from the experiment")
    args = p.parse_args(argv)
    setup_log(log, args.debug)

    with h5.File(args.datafile, "r") as afp:
        for trial in oeaudio_to_trials(afp, args.sync):
            if trial["index"] > 2:
                break


if __name__ == "__main__":
    oeaudio_to_pprox_script()
