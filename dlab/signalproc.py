#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
"""
module with signal processing functions

CDM, 1/2007
 
"""

import scipy as nx
import scipy.fftpack as sfft
from scipy import weave
from linalg import outer,gemm

def stft(S, **kwargs):
    """
    Computes the short-time fourier transform of a time-domain
    signal S.  Data are split into NFFT length segments and the complex
    FFT of each segment is computed after applying a windowing function.
    Optional arguments and their default values are as follows

    nfft - Size of the FFT timeframe (default 320)
    window - the window applied to the samples before FFT
             this can be a function that generates the window or a 1D
             vector with the window values.  If a vector is supplied,
             the window is clipped or padded with zeros to match nfft
             By default scipy.signal.signaltools.hamming is used to generate
             the window
             
    To specify the lattice of window onsets, either directly
    specify a grid, or provide the parameters to make a grid.

    grid  - an array of integer onsets. No value may exceed the length
            of the input array
            
    onset  - starting sample of the input signal (default 0)
    offset - ending offset (relative to signal length)
    shift  - number of samples to shift the window by (default 10)

    Returns a 2D array C, which has nfft rows (nfft/2 for real inputs)
    and (len(S)/shift) columns

    """
    from scipy.signal import get_window
    from scipy.linalg import norm
    
    nfft = int(kwargs.get('nfft', 320))
    window = kwargs.get('window', 'hamming')

    if len(S) == 0:
        raise ValueError, "Empty input signal."

    if nfft <= 2:
        raise ValueError, "nfft must be greater than 2"

    # generate the window
    if callable(window):
        window = window(nfft)
    elif isinstance(window, str):
        window = get_window(window, nfft)
    elif len(window) != nfft:
        window.resize(nfft, refcheck=True)

    # normalize the window to a total power of 1

    # generate the grid
    if kwargs.has_key('grid'):
        grid = kwargs.get('grid')
    else:
        onset = int(kwargs.get('onset',0))
        offset = S.size - int(kwargs.get('offset',0))
        shift = int(kwargs.get('shift', 10))
        grid = nx.arange(onset, offset, shift)

    ncols = len(grid)
    S_tmp = nx.copy(S)
    S_tmp.resize(len(S) + nfft-1)
    workspace = nx.zeros((nfft, ncols),'d')

    for i in range(nfft):
        workspace[i,:] = S_tmp[grid+i-1] * window[i]

    C = sfft.fft(workspace, nfft, axis=0, overwrite_x=1)

    # correct for window power
    return C / norm(window)

def istft(C, **kwargs):
    """
    Estimates the real time series that gives rise to a particular
    time-frequency stft.  The input C is assumed to be conjugate
    complex (i.e. generated by stft)

    window - the window applied to the samples before FFT
             this can be a function that generates the window or a 1D
             vector with the window values.  If a vector is supplied,
             the window is clipped or padded with zeros to match nfft
             By default scipy.signal.signaltools.hamming is used to generate
             the window

    To specify the lattice of window onsets, either directly
    specify a grid, or provide the parameters to make a grid.

    grid  - an array of integer onsets. No value may exceed the length
            of the input array
            
    shift  - number of samples to shift the window by (default 10)             
    """
    from scipy.signal import get_window
    
    assert C.ndim > 1
    nrows, ncols = C.shape
    # if the array is conjugate, the imaginary component of DC and the Nyquist freq
    # will be 0.0
    assert nx.all(C.imag[0]==0.)
    if nrows % 2 == 0:
        assert nx.all(C.imag[nrows/2]==0.)

    # generate the grid
    if kwargs.has_key('grid'):
        grid = kwargs.get('grid')
    else:
        shift = kwargs.get('shift',10)
        grid = nx.arange(0,ncols*shift,shift)

    window = kwargs.get('window', 'hamming')
    if callable(window):
        W = window(nrows)
    elif isinstance(window, str):
        W = get_window(window, nrows)
    elif len(window) != nrows:
        window.resize(nrows, refcheck=True)    

    W2 = nx.power(W,2)

    # we can assume that the imaginary component is extremely small if the
    # above assertions are correct
    v_r = sfft.ifft(C, nrows, axis=0, overwrite_x=0).real

    # now we have to deconvolve the window function
    N = grid[-1] + nrows
    R = nx.zeros(N)
    diag = nx.zeros(N)
    for j in range(ncols):
        offset = grid[j]
        R[offset:offset+nrows] += W * v_r[:,j]
        diag[offset:offset+nrows] += W2

    ind = diag!=0.
    R[ind] = R[ind] / diag[ind]

    return R

    
def spectro(S, fun=stft, **kwargs):
    """
    Computes the spectrogram of a 1D time series, i.e. the 2-D
    power spectrum.

    fun - the function that computes the time-frequency density
          from the signal S.  If the result of this function is
          complex, the spectrogram is symmetric, and only the unique
          rows of the output are returned.  If the result of <fun>
          is real, the power spectrum is assumed to have been already
          cut in half and converted to power.
          
    Fs - the sampling rate of the signal, in Hz (default 20 kHz)
    nfft - the number of frequency bins to use
    shift - temporal resolution of the spectrogram, in # of samples

    Returns a tuple (PSD, T, F), where T and F are the bins
    for time and frequency
    """
    Fs = kwargs.get('Fs', 20000.)
    nfft = kwargs.get('nfft', 320)
    shift = kwargs.get('shift', 10)
    
    PSD = fun(S, **kwargs)
    if PSD.dtype.kind=='c':
        PSD = nx.absolute(PSD)  # compute power from full complex stft
    
    if S.dtype.kind!='c':
        if nx.remainder(nfft,2):
            nfft = (nfft+1)/2
            PSD = PSD[0:nfft, :]
            # double all frequencies except DC
            PSD[1:,:] *= 2
        else:
            nfft = nfft/2+1
            PSD = PSD[0:nfft,:]
            # double all frequencies except DC and nyquist
            PSD[1:-1,:] *= 2
        F = nx.arange(0, Fs/2., (Fs/2.)/PSD.shape[0])
    else:
        F = nx.arange(-Fs/2., Fs/2., float(Fs)/PSD.shape[0])

    # scale by sampling frequency for PSD
    # PSD /= Fs
    T = nx.arange(0, PSD.shape[1] * 1000. / Fs * shift, 1000. / Fs * shift)

    return (PSD, T, F)


def mtmspec(signal, **kwargs):
    """
    Computes the time-frequency power spectrogram of a signal using the
    multitaper method

    Arguments:
    nfft - number of points in the FFT transform (default 320)
    mtm_p - mtm bandwidth (see dpss) (default 3.5)
    adapt - whether to use the adaptive method to scale the contributions
            of the different tapers.

    Specify the lattice for the time intervals as in stft()

    Most of this code is translated from the MATLAB signal toolkit
 
    References: 
      [1] Thomson, D.J.'Spectrum estimation and harmonic analysis.'
          In Proceedings of the IEEE. Vol. 10 (1982). Pgs 1055-1096.
      [2] Percival, D.B. and Walden, A.T., 'Spectral Analysis For Physical
          Applications', Cambridge University Press, 1993, pp. 368-370. 
      [3] Mitra, P.P. and Pesearan, B. 'Analysis of Dynamic Brain
          Imaging Data', Biophys J 76 (1999), pp 691-708.
    """
    nfft = kwargs.get('nfft',320)
    mtm_p = kwargs.get('mtm_p',3.5)
    adapt = kwargs.get('adapt',True)
    
    assert signal.ndim == 1
    assert nfft > 0 and mtm_p > 0

    nrows = (nfft % 2) and nfft/2+1 or (nfft+1)/2
    
    # calculate dpss vectors
    (v,e) = dpss(nfft, mtm_p)
    ntapers = max(2*mtm_p-1,1)
    v = v[0:ntapers]

    # generate the grid
    if kwargs.has_key('grid'):
        grid = kwargs.get('grid')
    else:
        onset = int(kwargs.get('onset',0))
        offset = signal.size - int(kwargs.get('offset',0))
        shift = int(kwargs.get('shift', 10))
        grid = nx.arange(onset, offset, shift)

    ncols = len(grid)
    S_tmp = nx.array(signal, 'd')
    S_tmp.resize(len(signal) + nfft-1)    
    workspace = nx.zeros((nfft, ncols, ntapers),'d')
    sigpow = nx.zeros(ncols,'d')
    
    for i in range(nfft):
        val = S_tmp[grid+i-1]
        workspace[i,:,:] = outer(val,e[i,0:ntapers])
        sigpow += nx.power(val,2)  # dot product of the signal is used in mtm_adapt

    # calculate the windowed FFTs
    C = nx.power(nx.absolute(sfft.fft(workspace, nfft, axis=0, overwrite_x=1)),2)

    if adapt:
        S = mtm_adapt(C, v, sigpow / nfft)
    else:
        C.shape = (nfft * ncols, ntapers)
        S = gemm(C,v,alpha=1./ntapers)
        S.shape = (nfft, ncols)

    # for real signals the spectrogram is one-sided
    if signal.dtype.kind!='c':
        outrows = nfft % 2 and (nfft+1)/2 or nfft/2+1
        return S[0:outrows+1,:]
    else:
        return S



def mtm_adapt(Sk,V,sigpow):
    """
    Computes an adaptive average for mtm spectrogramtapers. Sk is a 3D
    array, (nfft, ncols, ntapers) V is a 1D array (ntapers,). Sigpow
    is a 1D array (ncols,) giving the normalized power in each window

    We have to compute an array of adaptive weights based on an initial
    estimate:
    w_{i,j,k}=(S_{i,j}/(S_{i,j}V_k + a_k))^2V_k

    a_k and the error tolerance is determined by the signal power in each window

    And then use the weights to calculate the new estimate:
    S_{i,j} = \sum_k w_{i,j,k} Sk_{i,j,k} / \sum_k w_{i,j,k}

    """
    assert Sk.ndim == 3
    assert len(V) == Sk.shape[2]

    ni,nj,nk = Sk.shape
    S = (Sk[:,:,0] + Sk[:,:,1])/2

    code = """
        # line 283 "signalproc.py"
	int i,j,k;
	double est, num, den, w;
        double sig2, tol, err;

	for (j=0;j<nj;j++) {
		sig2 = sigpow(j);
		tol = 0.0005 * sig2;
		err = 0;
		while (err > tol) {
			for (i=0; i < ni; i++) {
				est = S(i,j);
				num = den = 0;
				for (k=0; k < nk; k++) {
					w = est / (est * V(k) + sig2 * (1 -V(k)));
					w = pow(w,2) * V(k);
					num += w * Sk(i,j,k);
					den += w;
				}
				S(i,j) = num/den;
				err += fabs(num/den-est);
			}
		}
	}
    """

        
    weave.inline(code,['Sk','S','V','sigpow','ni','nj','nk'],
                 type_converters=weave.converters.blitz)

    return S
    

 
def dpss(npoints, mtm_p, k=None):
    """
    Computes the discrete prolate spherical sequences used in the
    multitaper method power spectrum calculations.

    npoints   the number of points in the window
    mtm_p     the time-bandwidth product. Must be an integer or half-integer
              (typical choices are 2, 5/2, 3, 7/2, or 4)
    k         If a scalar, returns the 1:k DPSS vectors
              If a 2-ple, returns the k[0]:k[1] DPSS vectors
              Default is to return all vectors

    returns:
    v - 2D array of eigenvalues, length n = (mtm_p * 2 - 1)
    e - 2D array of eigenvectors, shape (npoints, n)
    """
    from scipy.linalg import norm
    from linalg import tridisolve, tridieig

    if mtm_p >= npoints * 2:
        raise ValueError, "mtm_p may only be as large as npoints/2"

    W = float(mtm_p)/npoints
    
    if k==None:
        k = int(min(round(2*npoints*W),npoints))
        k = max(k,1)
    if not nx.iterable(k):
        k = [1, k]

    # generate diagonals
    d = (nx.power(npoints-1-2*nx.arange(0.,npoints), 2) * .25 * nx.cos(2*nx.pi*W)).real
    ee = nx.concatenate(([0], nx.arange(1.,npoints) * nx.arange(npoints-1,0.,-1)/2))
    v = tridieig(d, ee, npoints-k[1], npoints-k[0])
    v = v[::-1]
    ntapers = v.size

    # compute the eigenvectors
    E = nx.zeros((npoints,ntapers), dtype='d')
    t = nx.arange(0.,npoints)/(npoints-1)*nx.pi

    for j in range(ntapers):
        e = nx.sin((j+k[0])*t)
        e = tridisolve(ee, d-v[j], e)
        e = tridisolve(ee, d-v[j], e/norm(e))
        e = tridisolve(ee, d-v[j], e/norm(e))
        E[:,j] = e/norm(e)

    d = E.mean(0)
    for j in range(k[0],k[1]+1):
        i = j-k[0]
        if j % 2 == 1:
            # j is odd: symmetric dpss
            if d[i]<0.:
                E[:,i] = -E[:,i]            
        elif E[2,i]<0.: 
            # anti-symmetric dpss
            E[:,i] = -E[:,i]
            
    # calculate eigenvalues
    s = nx.concatenate(([2*W], 4*W*nx.sinc(2*W*nx.arange(1,npoints,dtype='d'))))
    # filter each taper with its flipped version
    fwd = sfft.fft(E,npoints*2,axis=0)
    rev = sfft.fft(nx.flipud(E),npoints*2,axis=0)
    q = (sfft.ifft(fwd * rev,axis=0)).real[0:npoints,:]
    #q = nx.asmatrix(q)

    V = gemm(q, nx.flipud(s), trans_a=1)
    V = nx.minimum(V,1)
    V = nx.maximum(V,0)
    V.shape = (ntapers,)

    return V,E

def sincresample(S, npoints, shift=0):
    """
    Resamples a signal S using sinc resampling and optional timeshifting.
    S is the input signal, which can be a vector or a 2D array of columns
    npoints is the number of points required in each column after resampling.

    shift is either a scalar or a vector equal in length to the number
    of columns in S, which indicates how much each channel should be timeshifted.
    This can be useful in compensating for sub-sampling rate skew in
    data acquisition. Shift values must be between -1 and 1.

    returns the resampled data, with the same number of columns and npoints rows

    Adapted from MATLAB code by Malcolm Lidierth, 07/06
    """
    
    x = nx.atleast_2d(S)
    x = nx.concatenate([nx.flipud(x), x, nx.flipud(x)], axis=0)
    np = npoints*3
    nt = x.shape[0]
    t  = nx.arange(nt)
    t.shape = (nt,1)

    ts = nx.linspace(0, nt, np)
    ts.shape = (np,1)
    ts = nx.kron(nx.ones(nt),ts) - nx.kron(nx.ones(np),t).transpose()

    # hamming window
    th = ts+nt-1
    w  = 0.54 - 0.46*nx.cos((2*nx.pi*th/th.max()))

    # shift in multiples of sampling interval
    ts += shift

    # sinc functions
    h = nx.sinc(ts) * w

    # convolution by matrix mult
    y = gemm(h, x)

    return y[npoints:npoints*2,:]

def fftresample(S, npoints, reflect=False, axis=0):
    """
    Resample a signal using discrete fourier transform. The signal
    is transformed in the fourier domain and then padded or truncated
    to the correct sampling frequency.  This should be equivalent to
    a sinc resampling.
    """
    from scipy.fftpack import rfft, irfft
    from dlab.datautils import flipaxis

    # this may be considerably faster if we do the memory operations in C
    # reflect at the boundaries
    if reflect:
        S = nx.concatenate([flipaxis(S,axis), S, flipaxis(S,axis)],
                           axis=axis)
        npoints *= 3

    newshape = list(S.shape)
    newshape[axis] = int(npoints)

    Sf = rfft(S, axis=axis)
    Sr = (1. * npoints / S.shape[axis]) * irfft(Sf, npoints, axis=axis, overwrite_x=1)
    if reflect:
        return nx.split(Sr,3)[1]
    else:
        return Sr


def fband(S, **kwargs):
    """
    Fband computes a spectrographic representation of the
    time-frequency distribution of a signal using overlapping Gaussian
    windowed frequency bands.  This is the method used by Theunissen
    et al (2000) to compute invertible STRFs

    S - real-valued signal, any precision

    optional arguments:
    Fs - sampling rate of signal (default 20 kHz)
    sil_window - number of ms to zero pad the signal with (default 0)
    f_low - the frequency of the lowest filter (default 250.)
    f_high - the frequency of the highest filter (default 8000.)
    f_width - the bandwidth of the overlapping filters (default 250.)

    Outputs a 2D array of doubles. The temporal resolution is 1 kHz

    The algorithm is pretty fast for short signals but requires way too
    much memory for long signals.  Need to replace with a an overlap-and-add
    fftfilt algo a la matlab.

    """

    Fs = kwargs.get('Fs',20000.)
    sil_window = kwargs.get('sil_window',0)
    f_low = kwargs.get('f_low',250.)
    f_high = kwargs.get('f_high',8000.)
    f_width = kwargs.get('f_width',250.)

    assert S.ndim == 1

    nframes = S.size
    nbands = int((f_high - f_low) / f_width)
    tstep = 1000. / Fs
    ntemps = int(nx.ceil(nframes * tstep))  # len in FET's code

    if tstep > 1.:
        raise ValueError, "Sampling rate of signal is too low"

    nwindow = int(nx.ceil(sil_window/tstep))
    c_n = int( nx.power(2., nx.floor(nx.log2(nframes+2.*nwindow+0.5)))+0.1)
    if c_n < nframes+2*nwindow: c_n *= 2
    #c_n = int((nframes+2.*nwindow) * 1.1)
    fres = 1. * Fs / c_n
    istart = (c_n - nframes)/2
    print "c_n = %d istart = %d nframes = %d nwindow=%d" %  (c_n, istart, nframes, nwindow)

    fres = 1. * Fs / c_n
    fstep = (f_high - f_low) / nbands
    f_width = fstep
    f2 = fstep * fstep
    print "New frequency step: low = %g high = %g step=%g" % (f_low, f_high, f_width)

    # perform filtering operation in the complex domain
    c_song = nx.zeros(c_n, 'd')
    c_song[istart:(istart+nframes)] = S

    # fft needs to be at least 2x the length of the signal
    c_song = sfft.fft(c_song, c_n*2, overwrite_x=1)
    #c_song = sfft.rfft(c_song, c_n*2, overwrite_x=1)    
    c_filt = nx.zeros((nbands, c_n*2), dtype=c_song.dtype)
    f = nx.arange(c_n*2.) * fres / 2
    #f = nx.repeat(nx.arange(1. * c_n) * fres, 2)

    for nb in range(nbands):
        fmean = f_low + (nb+0.5)*fstep
        df = f - fmean
        c_filt[nb,:] = nx.exp(-0.5 * df * df / f2)
        
    c_song.shape = (1,c_n*2)
    # filter and back to real domain
    c_song = sfft.ifft((c_song * c_filt), axis=1, overwrite_x=1)[:,0:c_n]
    #c_song = sfft.irfft((c_song * c_filt), axis=1, overwrite_x=1)[:,0:c_n]

    # amplitude envelope
    c_song = nx.absolute(c_song)
    # lowpass filter amplitude if fstep > 250 (implement later)

    # copy to the output array with nearest-neighbor interpolation
    j = nx.arange(ntemps + 2 * sil_window)
    i_val = (j - sil_window ) / tstep
    i_low = nx.floor(i_val).astype('i') + istart
    i_high = nx.ceil(i_val).astype('i') + istart
    a_low = c_song[:,i_low]
    if nx.any(a_low < 0.):
        print "Warning: amplitude values < 0.0 @ %s" % (a_low < 0).nonzero()[0]
        a_low[a_low<0.] = 0.
    a_val = (1. + i_low - i_val) * a_low
    
    if nx.any(i_low != i_high):
        a_high = c_song[:,i_high]
        a_high[a_high < 0.] = 0.
        a_val += (1. + i_val - i_high) * a_high
    
    return nx.sqrt(a_val)

def autocorr(S, **kwargs):
    """
    Computes the autocorrelation matrix of one or more signals. This
    is the autocorrelation of each signal with all other signals,
    including itself.  The matrix is symmetric, and is returned as
    an NxM matrix, with N samples in the autocorrelation window
    and M = (n choose 2) where n is the number of signals. The
    pairings for each function are stored in order,
    e.g. (1,1),(1,2),...(1,n),(2,2)...(n,n)

    The input S should be a vector or matrix with signals in the columns

    Optional parameters:
    Fs - the sampling rate of the signals (default 1)
    window - the number of sampling intervals (samples/Fs) on either side
             (default 200)
    mcorrect - whether to subtract off the mean of the signal in each column
               (default false)
    """

    if S.ndim==1: S = nx.atleast_2d(S).T

        
    Fs = kwargs.get('Fs',1.)
    window = kwargs.get('window', 200.)
    TWINDOW = int(window * Fs)

    nsamp,nband = S.shape
    ncorr = (nband*(nband-1))/2 + nband
    if kwargs.get('mcorrect',False):
        m = S.mean(axis=0)
    else:
        m = nx.zeros(nband)

    A = nx.zeros((2*TWINDOW+1, ncorr))
    n = nx.zeros((2*TWINDOW+1, 1),'i')

    code = """
         # line 553 "signalproc.py"
         int ib1, ib2, it1, it2, st, xb;
         double stim1, stim2;
         xb = 0;
         for ( ib1 = 0; ib1 < nband; ib1++) {
              for ( ib2 = ib1; ib2 < nband; ib2++) {
                   for ( it1 = 0; it1 < nsamp; it1++) {
                        stim1 = S(it1,ib1) - m(ib1);
                        for (it2 = it1-TWINDOW; it2 <= it1+TWINDOW; it2++) {
                             if (it2 < 0) continue;
                             else if (it2 >= nsamp) break;

                             st = it2 - it1 + TWINDOW;
                             A(st,xb) += stim1 * (S(it2,ib2) - m(ib2));
                             n(st) += 1;
                        }
                   }
                   xb += 1;
              }
        }
    """

    weave.inline(code,
                 ['S','TWINDOW','nband','nsamp','A', 'n','m'],
                 type_converters=weave.converters.blitz)

    return A / n

def threshold(signal, thresh):
    """
    Thresholds a signal. The signal is adjusted by <thresh> and
    then rectified.
    """
    sig = signal.copy()
    sig -= thresh
    sig[sig<0.] = 0.
    return sig

def signalstats(S):
    """  Compute dc offset and rms from a signal  """
    # we want to compute these stats simultaneously
    # it's 200x faster than .mean() and .var()!

    assert S.ndim == 1, "signalstats() can only handle 1D arrays"
    out = nx.zeros((2,))
    code = """
         #line 618 "signalproc.py"
         double e = 0;
         double e2 = 0;
         double v;
         int nsamp = NS[0];
         for (int i = 0; i < nsamp; i++) {
              v = (double)S[i];
              e += v;
              e2 += v * v;
         }
         out[0] = e / nsamp;
         out[1] = sqrt(e2 / nsamp - out[0] * out[0]);

         """
    weave.inline(code, ['S','out'])
    return out

def getfgrid(Fs,nfft,fpass):
    """
    Helper function that gets the frequency grid associated with a given fft based computation
    Called by spectral estimation routines to generate the frequency axes 
    Usage: [f,findx]=getfgrid(Fs,nfft,fpass)
    Inputs:
    Fs        (sampling frequency associated with the data)-required
    nfft      (number of points in fft)-required
    fpass     (band of frequencies at which the fft is being calculated [fmin fmax] in Hz)-required
    Outputs:
    f         (frequencies)
    findx     (index of the frequencies in the full frequency grid). e.g.: If
    Fs=1000, and nfft=1048, an fft calculation generates 512 frequencies
    between 0 and 500 (i.e. Fs/2) Hz. Now if fpass=[0 100], findx will
    contain the indices in the frequency grid corresponding to frequencies <
    100 Hz. In the case fpass=[0 500], findx=[1 512].

    From Chronux 1_50
    """
    
    df = float(Fs)/ nfft
    f = nx.arange(0,Fs,df)  # all possible frequencies

    if len(fpass)!=1:
        findx = ((f>=fpass[0]) & (f<=fpass[-1])).nonzero()[0]
    else:
        findx = nx.abs(f-fpass).argmin()

    return f[findx], findx

if __name__=="__main__":

    from dlab import pcmio
    S = pcmio.sndfile('/z1/users/dmeliza/stimsets/stimuli/B0.pcm').read()
    
