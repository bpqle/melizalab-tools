#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
"""
module with signal processing functions

CDM, 1/2007
 
"""

import scipy as nx
import scipy.fftpack as sfft
from scipy.linalg import norm, get_blas_funcs
from scipy.signal import hamming, fftconvolve
from scipy import weave
import tridiag

# reference some fast BLAS functions
# matrix vector multiplication:
gemv,= get_blas_funcs(('gemv',),(nx.array([1.,2.],'d'),))
# outer product
ger, = get_blas_funcs(('ger',),(nx.array([1.,2.],'d'),))



def stft(S, **kwargs):
    """
    Computes the short-time fourier transform of a time-domain
    signal S.  Data are split into NFFT length segments and the complex
    FFT of each segment is computed after applying a windowing function.
    Optional arguments and their default values are as follows

    nfft - Size of the FFT timeframe (default 320)
    window - the window applied to the samples before FFT
             this can be a function that generates the window or a 1D
             vector with the window values.  If a vector is supplied,
             the window is clipped or padded with zeros to match nfft
             By default scipy.signal.signaltools.hamming is used to generate
             the window
             
    To specify the lattice of window onsets, either directly
    specify a grid, or provide the parameters to make a grid.

    grid  - an array of integer onsets. No value may exceed the length
            of the input array
            
    onset  - starting sample of the input signal (default 0)
    offset - ending offset (relative to signal length)
    shift  - number of samples to shift the window by (default 10)

    Returns a 2D array C, which has nfft rows (nfft/2 for real inputs)
    and (len(S)/shift) columns

    """
    nfft = int(kwargs.get('nfft', 320))
    window = kwargs.get('window', hamming)

    if len(S) == 0:
        raise ValueError, "Empty input signal."

    if nfft <= 2:
        raise ValueError, "nfft must be greater than 2"

    # generate the window
    if callable(window):
        window = window(nfft)
    elif len(window) != nfft:
        window.resize(nfft, refcheck=True)

    # generate the grid
    if kwargs.has_key('grid'):
        grid = kwargs.get('grid')
    else:
        onset = int(kwargs.get('onset',0))
        offset = S.size - int(kwargs.get('offset',0))
        shift = int(kwargs.get('shift', 10))
        grid = nx.arange(onset, offset, shift)

    ncols = len(grid)
    S_tmp = nx.copy(S)
    S_tmp.resize(len(S) + nfft-1)
    workspace = nx.zeros((nfft, ncols),'d')

    for i in range(nfft):
        workspace[i,:] = S_tmp[grid+i-1] * window[i]

    C = sfft.fft(workspace, nfft, axis=0, overwrite_x=1)
    return C

def istft(C, **kwargs):
    """
    Estimates the real time series that gives rise to a particular
    time-frequency stft.  The input C is assumed to be conjugate
    complex (i.e. generated by stft)

    window - the window applied to the samples before FFT
             this can be a function that generates the window or a 1D
             vector with the window values.  If a vector is supplied,
             the window is clipped or padded with zeros to match nfft
             By default scipy.signal.signaltools.hamming is used to generate
             the window

    To specify the lattice of window onsets, either directly
    specify a grid, or provide the parameters to make a grid.

    grid  - an array of integer onsets. No value may exceed the length
            of the input array
            
    shift  - number of samples to shift the window by (default 10)             
    """
    assert C.ndim > 1
    nrows, ncols = C.shape
    # if the array is conjugate, the imaginary component of DC and the Nyquist freq
    # will be 0.0
    assert nx.all(C.imag[0]==0.)
    if nrows % 2 == 0:
        assert nx.all(C.imag[nrows/2]==0.)

    # generate the grid
    if kwargs.has_key('grid'):
        grid = kwargs.get('grid')
    else:
        shift = kwargs.get('shift',10)
        grid = nx.arange(0,ncols*shift,shift)

    window = kwargs.get('window', hamming)
    W = window(nrows)
    W2 = nx.power(W,2)

    # we can assume that the imaginary component is extremely small if the
    # above assertions are correct
    v_r = sfft.ifft(C, nrows, axis=0, overwrite_x=0).real

    # now we have to deconvolve the window function
    N = grid[-1] + nrows
    R = nx.zeros(N)
    diag = nx.zeros(N)
    for j in range(ncols):
        offset = grid[j]
        R[offset:offset+nrows] += W * v_r[:,j]
        diag[offset:offset+nrows] += W2

    ind = diag!=0.
    R[ind] = R[ind] / diag[ind]

    return R

    
def spectro(S, fun=stft, **kwargs):
    """
    Computes the spectrogram of a 1D time series, i.e. the 2-D
    power spectrum.

    fun - the function that computes the time-frequency density
          from the signal S.  If the result of this function is
          complex, the spectrogram is symmetric, and only the unique
          rows of the output are returned.  If the result of S
          is real, the power spectrum is assumed to have been already
          cut in half and converted to power.
          
    Fs - the sampling rate of the signal, in Hz (default 20 kHz)

    Returns a tuple (PSD, T, F), where T and F are the bins
    for time and frequency
    """
    Fs = kwargs.get('Fs', 20000.)
    nfft = kwargs.get('nfft', 320)
    shift = kwargs.get('shift', 10)
    
    PSD = fun(S, **kwargs)
    if PSD.dtype.kind=='c':
        PSD = nx.power(nx.absolute(PSD),2)  # compute power from full complex stft
    
    if S.dtype.kind!='c':
        nfft = nx.floor(nfft/2)
        PSD = PSD[1:(nfft+2), :]
        F = nx.arange(0, Fs/2., (Fs/2.)/PSD.shape[0])
    else:
        F = nx.arange(-Fs/2., Fs/2., float(Fs)/PSD.shape[0])
    
    PSD = nx.log10(PSD)
    PSD[PSD<0] = 0

    T = nx.arange(0, PSD.shape[1] * 1000. / Fs * shift, 1000. / Fs * shift)

    return (PSD, T, F)


def mtmspec(signal, **kwargs):
    """
    Computes the time-frequency power spectrogram of a signal using the
    multitaper method

    Arguments:
    nfft - number of points in the FFT transform (default 320)
    mtm_p - mtm bandwidth (see dpss) (default 3.5)
    adapt - whether to use the adaptive method to scale the contributions
            of the different tapers.

    Specify the lattice for the time intervals as in stft()

    Most of this code is translated from the MATLAB signal toolkit
 
    References: 
      [1] Thomson, D.J.'Spectrum estimation and harmonic analysis.'
          In Proceedings of the IEEE. Vol. 10 (1982). Pgs 1055-1096.
      [2] Percival, D.B. and Walden, A.T., 'Spectral Analysis For Physical
          Applications', Cambridge University Press, 1993, pp. 368-370. 
      [3] Mitra, P.P. and Pesearan, B. 'Analysis of Dynamic Brain
          Imaging Data', Biophys J 76 (1999), pp 691-708.
    """
    nfft = kwargs.get('nfft',320)
    mtm_p = kwargs.get('mtm_p',3.5)
    adapt = kwargs.get('adapt',True)
    
    assert signal.ndim == 1
    assert nfft > 0 and mtm_p > 0

    nrows = (nfft % 2) and nfft/2+1 or (nfft+1)/2
    
    # calculate dpss vectors
    (v,e) = dpss(nfft, mtm_p)
    ntapers = max(2*mtm_p-1,1)
    v = v[0:ntapers]

    # generate the grid
    if kwargs.has_key('grid'):
        grid = kwargs.get('grid')
    else:
        onset = int(kwargs.get('onset',0))
        offset = signal.size - int(kwargs.get('offset',0))
        shift = int(kwargs.get('shift', 10))
        grid = nx.arange(onset, offset, shift)

    ncols = len(grid)
    S_tmp = nx.array(signal, 'd')
    S_tmp.resize(len(signal) + nfft-1)    
    workspace = nx.zeros((nfft, ncols, ntapers),'d')
    sigpow = nx.zeros(ncols,'d')
    
    for i in range(nfft):
        val = S_tmp[grid+i-1]
        workspace[i,:,:] = ger(1.,val,e[i,0:ntapers])
        sigpow += nx.power(val,2)  # dot product of the signal is used in mtm_adapt

    # calculate the windowed FFTs
    C = nx.power(nx.absolute(sfft.fft(workspace, nfft, axis=0, overwrite_x=1)),2)

    if adapt:
        S = mtm_adapt(C, v, sigpow / nfft)
    else:
        C.shape = (nfft * ncols, ntapers)
        S = gemv(1./ntapers,C,v)
        S.shape = (nfft, ncols)

    # for real signals the spectrogram is one-sided
    if signal.dtype.kind!='c':
        outrows = nfft % 2 and (nfft+1)/2 or nfft/2+1
        return S[0:outrows+1,:]
    else:
        return S



def mtm_adapt(Sk,V,sigpow):
    """
    Computes an adaptive average for mtm spectrogramtapers. Sk is a 3D
    array, (nfft, ncols, ntapers) V is a 1D array (ntapers,). Sigpow
    is a 1D array (ncols,) giving the normalized power in each window

    We have to compute an array of adaptive weights based on an initial
    estimate:
    w_{i,j,k}=(S_{i,j}/(S_{i,j}V_k + a_k))^2V_k

    a_k and the error tolerance is determined by the signal power in each window

    And then use the weights to calculate the new estimate:
    S_{i,j} = \sum_k w_{i,j,k} Sk_{i,j,k} / \sum_k w_{i,j,k}

    """
    assert Sk.ndim == 3
    assert len(V) == Sk.shape[2]

    ni,nj,nk = Sk.shape
    S = (Sk[:,:,0] + Sk[:,:,1])/2

    code = """
        # line 193 "signalproc.py"
	int i,j,k;
	double est, num, den, w;
        double sig2, tol, err;

	for (j=0;j<nj;j++) {
		sig2 = sigpow(j);
		tol = 0.0005 * sig2;
		err = 0;
		while (err > tol) {
			for (i=0; i < ni; i++) {
				est = S(i,j);
				num = den = 0;
				for (k=0; k < nk; k++) {
					w = est / (est * V(k) + sig2 * (1 -V(k)));
					w = pow(w,2) * V(k);
					num += w * Sk(i,j,k);
					den += w;
				}
				S(i,j) = num/den;
				err += fabs(num/den-est);
			}
		}
	}
    """

        
    weave.inline(code,['Sk','S','V','sigpow','ni','nj','nk'],
                 type_converters=weave.converters.blitz)

    return S
    

 
def dpss(npoints, mtm_p):
    """
    Computes the discrete prolate spherical sequences used in the
    multitaper method power spectrum calculations.

    npoints - the number of points in the window
    mtm_p - the time-bandwidth product. Must be an integer or half-integer
            (typical choices are 2, 5/2, 3, 7/2, or 4)

    returns:
    v - 2D array of eigenvalues, length n = (mtm_p * 2 - 1)
    e - 2D array of eigenvectors, shape (npoints, n)
    """

    if mtm_p >= npoints * 2:
        raise ValueError, "mtm_p may only be as large as npoints/2"

    W = float(mtm_p)/npoints
    ntapers = int(min(round(2*npoints*W),npoints))
    ntapers = max(ntapers,1)

    # generate diagonals
    d = (nx.power(npoints-1-2*nx.arange(0.,npoints), 2) * .25 * nx.cos(2*nx.pi*W)).real
    ee = nx.arange(1.,npoints) * nx.arange(npoints-1,0.,-1)/2

    v = tridiag.dstegr(d, nx.concatenate((ee, [0])), npoints-ntapers+1, npoints)[1]
    v = nx.flipud(v[0:ntapers])

    # compute the eigenvectors
    E = nx.zeros((npoints,ntapers), dtype='d')
    t = nx.arange(0.,npoints)/(npoints-1)*nx.pi

    for j in range(ntapers):
        e = nx.sin((j+1.)*t)
        e = tridiag.dgtsv(ee,d-v[j],ee,e)[0]
        e = tridiag.dgtsv(ee,d-v[j],ee,e/norm(e))[0]
        e = tridiag.dgtsv(ee,d-v[j],ee,e/norm(e))[0]
        E[:,j] = e/norm(e)

    d = E.mean(0)

    for j in range(ntapers):
        if j % 2 == 1:
            if E[2,j]<0.: 
                # anti-symmetric dpss
                E[:,j] = -E[:,j]
        elif d[j]<0.:
            E[:,j] = -E[:,j]
            
    # calculate eigenvalues
    s = nx.concatenate(([2*W], 4*W*sinc(2*W*nx.arange(1,npoints,dtype='d'))))
    # filter each taper with its flipped version
    fwd = sfft.fft(E,npoints*2,axis=0)
    rev = sfft.fft(nx.flipud(E),npoints*2,axis=0)
    q = (sfft.ifft(fwd * rev,axis=0)).real[0:npoints,:]
    #q = nx.asmatrix(q)

    V = gemv(1.,q.transpose(),nx.flipud(s))
    V = nx.minimum(V,1)
    V = nx.maximum(V,0)
    V.shape = (ntapers,)

    return (V,E)

def sinc(v):
    return nx.sin(v * nx.pi)/(v * nx.pi)
