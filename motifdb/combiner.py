#!/usr/bin/env python
# -*- coding: iso-8859-1 -*-
"""
combines features into motifs and motifs into sequences

CDM, 1/2007
 
"""

import re
from dlab import datautils, pcmio
from numpy import recarray

class seqparser(object):
    """
    Parses symbolic representations of artificial stimuli.
    Subclasses of this class define a grammatical mapping between
    symbolic (i.e. character) representations of a sequence,
    and a list of objects that can be collected into a single
    time series.
    """

    def __init__(self, db):
        """
        Instantiate the parser with a connection to a motifdb.
        """
        self.db = db

    def __str__(self):
        return "seqparser(%s)" % self.__class__.__name__

    def parse(self, symstr):
        """
        Translates a symbolic string representation of a stimulus
        into a list of component objects.
        """
        pass

class motifseq(seqparser):
    """
    Constructs sequences of motifs. These can be motifs from the motif
    database, or they can be motifs generated by artificial recombination
    of features. The feature-recombiner object is aggregated, which
    allows any seqparser to be used to resolve symbols

    The parser expects symbolic strings of the form <motif1> <motif2>
    <motif3>, where <motifN> is either a base motif name defined in
    the database (e.g. A2), or a synthetic construct that can be
    generated by one of the parsers supplied during instantiation.
        
    """

    def __init__(self, db, parsers=[], **kwargs):
        """
        Instantiate the parser with a connection to a motifdb
        and a list of parsers to resolve symbol names. Parsers
        are used in the order supplied. 

        Optional arguments:
        motif_gap - the amount of space to insert between motifs (default 100 ms)

        """
        seqparser.__init__(self, db)
        self._parsers = parsers
        self._opts = kwargs

    def parse(self, motifs):

        if isinstance(motifs, str):
            motifs = motifs.split(' ')
        
        symbols = self.db.get_motifs()
        out = []
        
        for motif in motifs:
            if motif in symbols:
                out.append(self.db.get(motif))
                print "--> %s is a defined motif" % motif
            else:
                parsed = False
                for parser in self._parsers:
                    try:
                        out.append(parser.parse(motif))
                        parsed = True
                        print "--> %s recognizes %s" % (parser, motif)
                        break
                    except:
                        pass
                if not parsed:
                    raise ValueError, "The motif %s was unparseable" % motif

        return out
                
    def getsignal(self, symstr):
        """
        Generates the pcm signal associated with the symbolic string.
        """
        motifs = self.parse(symstr)
        # figure out the Fs
        Fs = isinstance(motifs[0],featureset) and motifs[0].Fs or motifs[0]['Fs']
        prepend = int(self._opts.get('motif_gap', 100) * Fs / 1000)
        
        offsets = []
        data = []
        offset = prepend
        for motif in motifs:
            offsets.append(offset)
            if isinstance(motif, featureset):
                S = self.db.reconstruct(motif)
            else:
                wavfile = self.db.get_motif_data(motif['name'])
                s = pcmio.sndfile(wavfile)
                S = s.read()
                
            data.append(S)
            offset += len(S) + prepend

        return datautils.offset_add(offsets, data)
        
        

class featmerge(seqparser):
    """
    Reconstructs motifs from features.  The grammar assumes that
    most reconstructions will be based on a single motif. Types
    of reconstructions include (in order of increasing complexity):
            - complete reconstructions (all features)
            - partial reconstructions (subset of features)
            - reconstructions with time or frequency shifted features
            - substitutions or insertions of features from other motifs
            - substitutions or insertions of artificial noises

    The grammar uses a modified slice notation. Using A2 and
    featuremap 0 as an example:

    A2_0(:)   - a complete reconstruction of A2 based on featuremap 0
    A2_0      - shortcut for the above

    A2_0(1)   - feature 1 from A2. This differs from A2_0.1 in that feature
                1 is embedded at its original temporal offset

    A2_0(1:3) - features 1 through 3 from A2

    A2_0(1,2,5) - features 1,2,5 from A2

    A2_0(-1)	- all the features from A2 except 1

    A2_0(-1:4) 	- all the features except 1..4.

    Comma and slice notation can be combined, as in
    A2_0(1:2,5). However,negative and positive indices cannot
    be combined, because a negative index (or range) implies
    subtraction from the set of all features. The parser
    will raise an error if positive and negative indices
    are combined.

    Extended slicing (eg 1:5:2) is not supported; however (2:) can be
    used to refer to all the features from 2 to the last one

    Individual atoms can take advantage of the following syntax for
    modifying feature placement.

    A2_0(1,2t50)    - consists of feature 1 from A2, placed at its original
                    location, and feature 2, placed 50 ms later than its
                    original location.  Negative offsets work as well.

    A2_0(1,2f50)    - same as above, but feature 2 is upshifted 50 Hz.

    A2_0(-2f50)     - In this case, the entire motif is reconstructed,
                      but feature 2 is replaced by a 50-ms shifted version.

    Modifiers may be combined, and other modifiers can be
    defined. Modified features do not count as duplicates, so (2,2t50)
    is legal, as is (-2t50 -2t100).  However, (-2,-2t50) is not legal
    (because -2t50 implies -2)

    Finally, the notation can accept 'foreign' features and artificial
    sounds. For example, the following replaces feature 1 with feature
    2 from B2. The offset of any foreign feature is considered to be
    0.

    A2_0(-1,B2_0.2t100)
    """

    _re_base = re.compile(r"(?P<motif>\S+)_(?P<featmap>\d+)(?P<opts>\((?P<components>.+)\))?")
    _re_feat = re.compile(r"(?P<motif>\S+)_(?P<featmap>\d+).(?P<feature>\d+)(?P<opts>.*)")
    _re_opted = re.compile(r"(?P<feature>\d+)(?P<opts>\D+.*)")

    def parse(self, symstr):
        """
        Parses a symbolic string into a list of feature objects. Returns
        a tuple containing this list and the length (in ms) of the base motif
        """

        mm = self._re_base.match(symstr)
        if not mm:
            raise ValueError, "Input string is agrammatical"

        mm = mm.groupdict()
        if not mm['opts']:
            mm['components'] = ':'

        # load the motif and featuremap, which will throw errors if they're invalid
        motif = self.db.get(mm['motif'])
        fmap_name = "%(motif)s_%(featmap)s" % mm
        fmap  = self.db.get(fmap_name)
        nfeats = fmap['nfeats']

        posfeats = grouchyset([])
        negfeats = grouchyset([])
        outfeats = []
        for item in mm['components'].split(','):
            neg   = item.startswith('-')
            if neg: item = item[1:]
            colon = item.find(':')

            if colon == 0:
                # handle ':'
                posfeats.update(range(nfeats))
            elif colon > 0:
                # handle slices
                start = int(item[0:colon])
                stop  = item[colon+1:]
                stop  = stop and int(stop) or nfeats
                rng   = range(start,stop)
                if neg: negfeats.update(rng)
                else:   posfeats.update(rng)
            else:
                # everything else
                if item.isdigit():
                    # plain number
                    if neg: negfeats.add(int(item))
                    else:   posfeats.add(int(item))
                else:
                    # repositioned motifs or artificial ones
                    m = self._re_feat.match(item)
                    if m:
                        if neg:
                            raise ValueError, "You can't negate an external feature (%s)" % item
                        # insert other motif's feature
                        feat = self.db.get("%(motif)s_%(featmap)s.%(feature)s" % m.groupdict())
                        # reset the start time
                        feat['offset'][0] = 0.
                        if m.group('opts'):
                            self.__applyopts(feat, m.group('opts'))
                        outfeats.append(feat)
                        continue
                    m = self._re_opted.match(item)
                    if m:
                        # insert feature after modifying it
                        # note that "2t50" implies "-2"
                        feat = self.db.get("%s.%s" % (fmap_name, m.group('feature')))
                        self.__applyopts(feat, m.group('opts'))
                        if neg: negfeats.add(int(m.group('feature')))
                        outfeats.append(feat)
                        continue

                    raise ValueError, "Can't parse item (%s)" % item

        #print "Positives --> %s" % posfeats
        #print "Negatives --> %s" % negfeats
        # end loop through items
        if len(negfeats) > 0 and len(posfeats) > 0:
            raise ValueError, "Cannot have both positive and negative indices"
        if len(negfeats) > 0:
            posfeats = set(range(nfeats)).difference(negfeats)

        # compute the set of features from this motif
        motif_feats = self.db.get_features(mm['motif'],int(mm['featmap']))
        for f in posfeats:
            outfeats.append(self.db.get("%s.%s" % (fmap_name, f)))

        return featureset(outfeats,
                          motif['length'],
                          motif['Fs'])
                          

    def __applyopts(self, feat, options):
        """
        Applies transformations to a feature.  Currently we understand one,
        t<number>, which adjusts the time of the feature by <number> ms
        """
        if options.startswith('t'):
            offset = options[1:]
            feat['offset'][0] += float(offset)
        else:
            raise ValueError, "Unable to parse feature options %s for %d" % (options, feat['id'])


class oldfeatmerge(featmerge):
    """
    This class parses old-style synthetic motif grammars. Some sample
    translations:

    A2-0 -> A2_0(-0)
    B6-3-4 -> B6_0(-3,-4)
    CcR  -> Cc_0
    Bb.1 -> Bb_0(1)
    """

    def parse(self, symbol):

        # we're going to assume that no motifs have more than two characters
        motif = symbol[0:2]
        if symbol[2]=='R':
            return featmerge.parse(self, motif + "_0")
        elif symbol[2]=='.':
            posfeats = symbol[3:].split('.')
            return featmerge.parse(self, "%s_0(%s)" % (motif, ','.join(posfeats)))
        elif symbol[2]=='-':
            negfeats = symbol[3:].split('-')
            negfeats = ['-'+f for f in negfeats]
            return featmerge.parse(self, "%s_0(%s)" % (motif, ','.join(negfeats)))
        else:
            raise ValueError, "Unable to parse symbol %s" % symbol
        
        
        
    


class featureset(recarray):
    """
    Container to hold a bunch of features and some metadata
    """
    
    def __new__(cls, data, length, Fs):
        """
        Create a new feature set from a list of records. The feature
        set is initialized with a set of feature records, and the
        following required bits of metadata:

        min_length - reconstructions should be padded out to at least this long
        Fs         - the sampling rate of the features
        """
        self = recarray.__new__(cls, len(data), dtype=data[0].dtype)
        return self

    def __init__(self, data, length, Fs):
        for i in range(len(data)):
            self[i] = data[i]
        self.length = length
        self.Fs = Fs


class grouchyset(set):
    """
    This set throws an error if you try to add items that already
    exist.
    """
    def add(self, new):
        if self.__contains__(new):
            raise ValueError, "The item %s already exists" % new
        
        set.add(self, new)

    def update(self, new):
        if len(self.intersection(new)):
            raise ValueError, "The set already contains %s" % new
        set.update(self, new)
